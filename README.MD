# MEL Enumeration Pipeline

This project provides a multi-step pipeline for generating, processing, and enumerating MEL data from custom synthons and reactions

## ğŸ§© Project Structure
```
MEL_Project/
â”œâ”€â”€ mel_package/                  
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ 1_generate.py              
â”‚   â”œâ”€â”€ 2_process_generation.py              
â”‚   â”œâ”€â”€ 3_enumerate.py             
â”‚   â””â”€â”€ functions/              
â”‚       â””â”€â”€ ...                  
â”‚
â”œâ”€â”€ configs/                   
â”‚   â””â”€â”€ 1_Generation.json
|   â””â”€â”€ 2_Process_Generation.json
|   â””â”€â”€ 3_Enumeration.json
â”‚
â”œâ”€â”€ MAIN_data/                       
â”‚   â”œâ”€â”€ FINAL_data/
â”‚   â”œâ”€â”€ Generated_MEL_on_FINAL_data/
â”‚   â”œâ”€â”€ Test_Input_1/
â”‚   â””â”€â”€ Test_Output_1/
â”‚
â”œâ”€â”€ scripts/                  
â”‚   â””â”€â”€ generate.sh
â”‚   â””â”€â”€ rocess_generation.sh
â”‚   â””â”€â”€ enumeration.sh
â”‚
â”œâ”€â”€ notebooks/                 
â”‚   â””â”€â”€ preprocess.ipynb
â”‚
â”œâ”€â”€ functional_jsons/                   
â”‚   â””â”€â”€ Filter_Config.json
|   â””â”€â”€ reaction_id_type_map.json
|   â””â”€â”€ reaction_id_with_counts.json
â”‚
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ README.md

```
---

## ğŸ§ª 1. Generate MEL

Takes a reaction table and synthon libraries to generate MELs.

### Comments 

custom_reaction_id: set path with file that have only reaction id column,
                         If set to false, filtering is skipped.

### ğŸ§¾ JSON Config Example (1_Generation.json)
```json
{
    "synthons_folder_path": "MAIN_data/SYNTHONS_by_reaction_id_modified_for_MEL",   // path to Folder with prepared synthons
    "reaction_file_path": "MAIN_data/REACTIONS_for_MEL.tsv",                   // File with reaction SMARTS
    "external_minimal_synthons_path": "MAIN_data/MIN_caps_for_generation",          // path tp Folder with CAPS

    "output_folder_path": "Generated_MEL",                                          

    "n_processes": 55,                                                             
    "custom_reaction_id": false,                                                    

    "consequent_processing": false,                                                 // (âš ï¸ usually do not change)
    "id_mapper_path": "functional_jsons/reaction_id_type_map.json"                  // (âš ï¸ usually do not change)
}

```
### Run
```bash
bash scripts/generation.sh 
```
---
## ğŸ§¹ 2. Process MELs

Processes generated MEL files into manageable chunks by MEL type.


### Comments 

### ğŸ§¾ JSON Config Example (2_Process_Generation.json)

```json
{
    "input_dir": "Generated_MEL/enumerated_MEL",
    "chunk_size": 50000,
    "mel_types": ["2_component", "3_component", "bridge"],
    "synthon_counts_with_bridge_position":"functional_jsons/reaction_id_with_counts.json"
}
```
### Run
```bash
bash scripts/process_generation.sh 
```
---
## ğŸ”„ 3. Enumerate MEL

Fully enumerates final molecules from MEL structures.

### Comments 

mel_type: Type of MEL structure. Possible values:
  - "2_component"
  - "3_component"
  - "bridge"

iteration_level: Enumeration depth. Possible values:
  - 1 or 2

path_to_input_csv: The input csv must contain a mel_synthon_id column.

filter_config_file_path: If set to a valid config file, filtering will be applied.
                         If set to false, filtering is skipped.

### ğŸ§¾ JSON Config Example (3_Enumeration.json)
```json
{    
    "syntons_folder_path": "main_data/SYNTHONS_by_reaction_id_modified_for_MEL",
    
    "reactions_file_path": "MAIN_data/REACTIONS_for_MEL.tsv",

    "minimal_caps_folder_path": "combined_all/MIN_caps_for_enumeration",

    "filter_config_file_path": "main_data/Filter_Config.json",

    "output_folder_path": "test_2/Test_3_comp_12M",
    "path_to_input_csv": "test_2/test_all_3comp_selected.csv",

    "mel_type":"3_component",
    "iteration_level": 2,

    "N_cores":30,
    "N_compounds_to_Enumerate": 1000000,

    "synthon_counts_with_bridge_position":"functional_jsons/Reaction_id_with_counts.json"   // (âš ï¸ usually do not change)
}

```

### Run
```bash
bash scripts/enumeration.sh
```

### CSM_id generation: 
`CS_t<mel_type>_f<fragments>_l<lengths>_o<order>_e0`

*Example*: CS_t2_f244_l14_o123_e0

CS â€“ fixed prefix for Chemspace.

`t<mel_type>` â€“ MEL type from the dataset:  
- `2` â€“ two-component MEL  
- `3` â€“ three-component MEL  
- `B` â€“ bridge-type MEL  

`f<fragments>` â€“ number of fragments, predicted from the MEL SMILES using  `predict_the_amount_of_fragments_by_for_MEL_SMILES()`.  

`l<lengths>` â€“ number of ids in `full_mel_synthon_id`.  

`o<order>` â€“ row position (1-based index) in the processed dataset.  

`e0` â€“ stands for MEL generation 


### CSM_id iteration 1: 
`CS_t<mel_type>_f<fragments>_l<lengths>_o<order>_e0` + `f<fragments>_l<lengths>_o<order>_e1`

`f<fragments>` â€“ number of fragments, predicted from the MEL SMILES using  `predict_the_amount_of_fragments_by_for_MEL_SMILES()`. (0 for 2 components)

`l<lengths>` â€“ number of ids in `full_mel_synthon_id`.  

`o<order>` â€“ row position (1-based index) in the processed dataset.  

`e1` â€“ stands for enumeration iteration 1.

### CSM_id iteration 2 : 
`CS_t<mel_type>_f<fragments>_l<lengths>_o<order>_e0_f<fragments>_l<lengths>_o<order>_e1` + `l<lengths>_o<order>_e2`

`l<lengths>` â€“ number of ids in `full_mel_synthon_id`.  

`o<order>` â€“ row position (1-based index) in the processed dataset.  

`e2` for enumeration iteration 2.


